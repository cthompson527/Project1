package edu.tamu.csce315;

/**
 * Created by Cory Thompson on 1/20/16.
 * Team created by the values passed into the constructor; Holds stats for the team needed to compute the Predicted Scoring Margin.
 */
public class Team implements Comparable<Team> {
    private String name;
    private int asm, to, dto, pendif, rettd;
    private double pya, dpya, rya, drya, psm;

    /**
     * Constructor for Team; Also calculates the psm (predicted scoring margin)
     * @param name The name of the team
     * @param asm Actual Scoring Margin
     * @param pya Passing Yards Per Attempt
     * @param dpya Defense Passing Yards Per Attempt
     * @param rya Rushing Yards Per Attempt
     * @param drya Definse Rushing Yards Per Attempt
     * @param to Turnovers committed on offense
     * @param dto Turnovers committed on defense
     * @param pendif Penalty differencial
     * @param rettd Returns for Touchdowns
     */
    public Team(String name, int asm, double pya, double dpya, double rya, double drya, int to, int dto, int pendif, int rettd) {
        this.name   = name;
        this.asm    = asm;
        this.to     = to;
        this.dto    = dto;
        this.pendif = pendif;
        this.rettd  = rettd;
        this.pya    = pya;
        this.dpya   = dpya;
        this.rya    = rya;
        this.drya   = drya;
        this.psm    = ((3.17 * rettd) - (0.06 * pendif) + (61.67 * pya) + (26.44 * rya) - (2.77 * to) - (67.5 * dpya) - (22.79 * drya) + (3.49 * dto));
    }

    /**
     * Creates a team and uses default numbers (0).
     * @param name The name of the team
     */
    public Team(String name) {
        this(name, 0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0);
        psm = 0.0;
    }

    /**
     * Returns the asm
     * @return asm Actual Scoring Margin
     */
    public int getASM() {
        return asm;
    }

    /**
     * Returns the psm
     * @return psm: Predicted Scoring Margin
     */
    public double getPSM() {
        return psm;
    }

    /**
     * Uses String compare to compare name of each Team
     * @param o Object to compare
     * @return the value 0 if the argument Team's name is equal to this Team's name string; a value less than 0 if this Team's name string is lexicographically less than the Team's name string argument; and a value greater than 0 if this Team's name string is lexicographically greater than the Team's name string argument.
     */
    @Override
    public int compareTo(Team o) {
        if (this.equals(o))
            return 0;
        return this.name.compareTo(o.name);
    }


    /**
     * Generated by IntelliJ; Compares if two Teams are equal
     * @param o Object to compare
     * @return true if Teams are equal, and false if they are not
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Team team = (Team) o;

        if (asm != team.asm) return false;
        if (to != team.to) return false;
        if (dto != team.dto) return false;
        if (pendif != team.pendif) return false;
        if (rettd != team.rettd) return false;
        if (Double.compare(team.pya, pya) != 0) return false;
        if (Double.compare(team.dpya, dpya) != 0) return false;
        if (Double.compare(team.rya, rya) != 0) return false;
        if (Double.compare(team.drya, drya) != 0) return false;
        return name.equals(team.name);

    }

    /**
     * Generated by IntelliJ; Generates a hashCode unique for the Team
     * @return an integer hashCode unique for the Team
     */
    @Override
    public int hashCode() {
        int result;
        long temp;
        result = name.hashCode();
        result = 31 * result + asm;
        result = 31 * result + to;
        result = 31 * result + dto;
        result = 31 * result + pendif;
        result = 31 * result + rettd;
        temp = Double.doubleToLongBits(pya);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(dpya);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(rya);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        temp = Double.doubleToLongBits(drya);
        result = 31 * result + (int) (temp ^ (temp >>> 32));
        return result;
    }

    /**
     * Prints the name, actual scoring margin, and psm in a specific format
     * @return String of the name, actual scoring margin, and psm in a specific format
     */
    @Override
    public String toString() {
        return String.format("%-12s %4s\t%.2f", name, asm, getPSM());
    }
}
